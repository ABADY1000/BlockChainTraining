{
  "_args": [
    [
      "tape@^4.4.0",
      "/home/abady1000/BlockChain/Inbox/node_modules/web3-provider-engine"
    ]
  ],
  "_from": "tape@>=4.4.0 <5.0.0",
  "_hasShrinkwrap": false,
  "_id": "tape@4.14.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/tape",
  "_nodeVersion": "16.5.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/tape_4.14.0_1627447357593_0.09208231982221338"
  },
  "_npmUser": {
    "email": "ljharb@gmail.com",
    "name": "ljharb"
  },
  "_npmVersion": "7.19.1",
  "_phantomChildren": {},
  "_requested": {
    "name": "tape",
    "raw": "tape@^4.4.0",
    "rawSpec": "^4.4.0",
    "scope": null,
    "spec": ">=4.4.0 <5.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/web3-provider-engine"
  ],
  "_resolved": "https://registry.npmjs.org/tape/-/tape-4.14.0.tgz",
  "_shasum": "e4d46097e129817175b90925f2385f6b1bcfa826",
  "_shrinkwrap": null,
  "_spec": "tape@^4.4.0",
  "_where": "/home/abady1000/BlockChain/Inbox/node_modules/web3-provider-engine",
  "author": {
    "email": "mail@substack.net",
    "name": "James Halliday",
    "url": "http://substack.net"
  },
  "bin": {
    "tape": "bin/tape"
  },
  "bugs": {
    "url": "https://github.com/substack/tape/issues"
  },
  "dependencies": {
    "call-bind": "~1.0.2",
    "deep-equal": "~1.1.1",
    "defined": "~1.0.0",
    "dotignore": "~0.1.2",
    "for-each": "~0.3.3",
    "glob": "~7.1.7",
    "has": "~1.0.3",
    "inherits": "~2.0.4",
    "is-regex": "~1.1.3",
    "minimist": "~1.2.5",
    "object-inspect": "~1.11.0",
    "resolve": "~1.20.0",
    "resumer": "~0.0.0",
    "string.prototype.trim": "~1.2.4",
    "through": "~2.3.8"
  },
  "description": "tap-producing test harness for node and browsers",
  "devDependencies": {
    "@ljharb/eslint-config": "^17.6.0",
    "array.prototype.flatmap": "^1.2.4",
    "aud": "^1.1.5",
    "concat-stream": "^1.6.2",
    "eclint": "^2.8.1",
    "ecstatic": "^4.1.4",
    "es-value-fixtures": "^1.2.1",
    "eslint": "^7.31.0",
    "falafel": "^2.2.4",
    "js-yaml": "^3.14.0",
    "safe-publish-latest": "^1.1.4",
    "tap": "^8.0.1",
    "tap-parser": "^3.0.5"
  },
  "directories": {
    "example": "example",
    "test": "test"
  },
  "dist": {
    "fileCount": 114,
    "integrity": "sha512-z0+WrUUJuG6wIdWrl4W3rTte2CR26G6qcPOj3w1hfRdcmhF3kHBhOBW9VHsPVAkz08ZmGzp7phVpDupbLzrYKQ==",
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhAOA9CRA9TVsSAnZWagAAn3IP/0lJqEy7NoAwEn22CL/b\nEYkDNuZfcNGBepapp6Uuj55OW/IvGX9viIV1gdm/i10Sq/fz3YL/ovELqKGE\nM1qU8WFrGbQGdw7r7bsC+JIETh0GacJdgT+Jht3PhRUYq7XaQSiFHDZHcXHN\nJhurMQTNmQaOzTVcNuzs4i0295RsEg6NxlATiA7MlrRl66KXwho2ASTG9UAj\ni72IxA7Ob1NL/WOViDUQ93o+qx1Ihi8Zi9pnTm8DbdKDsn1VyJOL/kkN9ULQ\niD5HpakDmTvjsTDgLMo5AVPtZK9XR6+roeV7cfK0wj5+sOGOt0qS8YDlD6df\nVamF21Q1UyqCc9Zpj8B/FkGzEiEuXkqLg32jT7zi4j+vTcSG//4WNby+H7X2\n9B3RgN64KN8MXWZmAJ5ufSQwUiLqKJSJExr4SkojPUckT6j4ppPCKNFi4ySf\nmA/y31e0IExYg43kVZNtMkl9y6AN2o6ZrQ+tWn9a0+IfPmz2hKfeU372bIWz\nW6F538I42by90Kls0fOK3pSEiYJPDMIFT4uKMK7yMdivZEoVDMPne/5Q7oSU\nVO22X9OymyAV/xdVM3rIpeH8jr51QIJwloWfIJMAnOjWMJvGh7Dx8kinQIPT\ngTr2icG0DEk27vye4L95wvgEZtGG/USW8gyrYGG7zkBg4d6F/+K/TJ81lmvI\nInfg\r\n=extV\r\n-----END PGP SIGNATURE-----\r\n",
    "shasum": "e4d46097e129817175b90925f2385f6b1bcfa826",
    "tarball": "https://registry.npmjs.org/tape/-/tape-4.14.0.tgz",
    "unpackedSize": 201771
  },
  "gitHead": "af5b2f2225cbef6fb7d22533bc77796096ac5012",
  "homepage": "https://github.com/substack/tape",
  "keywords": [
    "assert",
    "browser",
    "harness",
    "tap",
    "test"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "domenic",
      "email": "d@domenic.me"
    },
    {
      "name": "substack",
      "email": "substack@gmail.com"
    },
    {
      "name": "raynos",
      "email": "raynos2@gmail.com"
    },
    {
      "name": "ljharb",
      "email": "ljharb@gmail.com"
    }
  ],
  "name": "tape",
  "optionalDependencies": {},
  "readme": "# tape\n\ntap-producing test harness for node and browsers\n\n[![github actions][actions-image]][actions-url]\n[![coverage][codecov-image]][codecov-url]\n\n![tape](https://web.archive.org/web/20170612184731if_/http://substack.net/images/tape_drive.png)\n\n# example\n\n``` js\nvar test = require('tape');\n\ntest('timing test', function (t) {\n    t.plan(2);\n\n    t.equal(typeof Date.now, 'function');\n    var start = Date.now();\n\n    setTimeout(function () {\n        t.equal(Date.now() - start, 100);\n    }, 100);\n});\n```\n\n```\n$ node example/timing.js\nTAP version 13\n# timing test\nok 1 should be equal\nnot ok 2 should be equal\n  ---\n    operator: equal\n    expected: 100\n    actual:   107\n  ...\n\n1..2\n# tests 2\n# pass  1\n# fail  1\n```\n\n# usage\n\nYou always need to `require('tape')` in test files. You can run the tests by\nusual node means (`require('test-file.js')` or `node test-file.js`). You can\nalso run tests using the `tape` binary to utilize globbing, on Windows for\nexample:\n\n```sh\n$ tape tests/**/*.js\n```\n\n`tape`'s arguments are passed to the\n[`glob`](https://www.npmjs.com/package/glob) module. If you want `glob` to\nperform the expansion on a system where the shell performs such expansion, quote\nthe arguments as necessary:\n\n```sh\n$ tape 'tests/**/*.js'\n$ tape \"tests/**/*.js\"\n```\n\n## Preloading modules\n\nAdditionally, it is possible to make `tape` load one or more modules before running any tests, by using the `-r` or `--require` flag. Here's an example that loads [babel-register](http://babeljs.io/docs/usage/require/) before running any tests, to allow for JIT compilation:\n\n```sh\n$ tape -r babel-register tests/**/*.js\n```\n\nDepending on the module you're loading, you may be able to parameterize it using environment variables or auxiliary files. Babel, for instance, will load options from [`.babelrc`](http://babeljs.io/docs/usage/babelrc/) at runtime.\n\nThe `-r` flag behaves exactly like node's `require`, and uses the same module resolution algorithm. This means that if you need to load local modules, you have to prepend their path with `./` or `../` accordingly.\n\nFor example:\n\n```sh\n$ tape -r ./my/local/module tests/**/*.js\n```\n\nPlease note that all modules loaded using the `-r` flag will run *before* any tests, regardless of when they are specified. For example, `tape -r a b -r c` will actually load `a` and `c` *before* loading `b`, since they are flagged as required modules.\n\n# things that go well with tape\n\n`tape` maintains a fairly minimal core. Additional features are usually added by using another module alongside `tape`.\n\n## pretty reporters\n\nThe default TAP output is good for machines and humans that are robots.\n\nIf you want a more colorful / pretty output there are lots of modules on npm\nthat will output something pretty if you pipe TAP into them:\n\n- [tap-spec](https://github.com/scottcorgan/tap-spec)\n- [tap-dot](https://github.com/scottcorgan/tap-dot)\n- [faucet](https://github.com/substack/faucet)\n- [tap-bail](https://github.com/juliangruber/tap-bail)\n- [tap-browser-color](https://github.com/kirbysayshi/tap-browser-color)\n- [tap-json](https://github.com/gummesson/tap-json)\n- [tap-min](https://github.com/derhuerst/tap-min)\n- [tap-nyan](https://github.com/calvinmetcalf/tap-nyan)\n- [tap-pessimist](https://www.npmjs.org/package/tap-pessimist)\n- [tap-prettify](https://github.com/toolness/tap-prettify)\n- [colortape](https://github.com/shuhei/colortape)\n- [tap-xunit](https://github.com/aghassemi/tap-xunit)\n- [tap-difflet](https://github.com/namuol/tap-difflet)\n- [tape-dom](https://github.com/gritzko/tape-dom)\n- [tap-diff](https://github.com/axross/tap-diff)\n- [tap-notify](https://github.com/axross/tap-notify)\n- [tap-summary](https://github.com/zoubin/tap-summary)\n- [tap-markdown](https://github.com/Hypercubed/tap-markdown)\n- [tap-html](https://github.com/gabrielcsapo/tap-html)\n- [tap-react-browser](https://github.com/mcnuttandrew/tap-react-browser)\n- [tap-junit](https://github.com/dhershman1/tap-junit)\n- [tap-nyc](https://github.com/MegaArman/tap-nyc)\n- [tap-spec (emoji patch)](https://github.com/Sceat/tap-spec-emoji)\n- [tape-repeater](https://github.com/rgruesbeck/tape-repeater)\n\nTo use them, try `node test/index.js | tap-spec` or pipe it into one\nof the modules of your choice!\n\n## uncaught exceptions\n\nBy default, uncaught exceptions in your tests will not be intercepted, and will cause `tape` to crash. If you find this behavior undesirable, use [`tape-catch`](https://github.com/michaelrhodes/tape-catch) to report any exceptions as TAP errors.\n\n## other\n\n- CoffeeScript support with https://www.npmjs.com/package/coffeetape\n- Promise support with https://www.npmjs.com/package/blue-tape or https://www.npmjs.com/package/tape-promise\n- ES6 support with https://www.npmjs.com/package/babel-tape-runner or https://www.npmjs.com/package/buble-tape-runner\n- Different test syntax with https://github.com/pguth/flip-tape (warning: mutates String.prototype)\n- Electron test runner with https://github.com/tundrax/electron-tap\n- Concurrency support with https://github.com/imsnif/mixed-tape\n- In-process reporting with https://github.com/DavidAnson/tape-player\n- Describe blocks with https://github.com/mattriley/tape-describe\n\n# methods\n\nThe assertion methods in `tape` are heavily influenced or copied from the methods\nin [node-tap](https://github.com/isaacs/node-tap).\n\n```js\nvar test = require('tape')\n```\n\n## test([name], [opts], cb)\n\nCreate a new test with an optional `name` string and optional `opts` object.\n`cb(t)` fires with the new test object `t` once all preceding tests have\nfinished. Tests execute serially.\n\nAvailable `opts` options are:\n- opts.skip = true/false. See test.skip.\n- opts.timeout = 500. Set a timeout for the test, after which it will fail. See test.timeoutAfter.\n- opts.objectPrintDepth = 5. Configure max depth of expected / actual object printing. Environmental variable `NODE_TAPE_OBJECT_PRINT_DEPTH` can set the desired default depth for all tests; locally-set values will take precedence.\n- opts.todo = true/false. Test will be allowed to fail.\n\nIf you forget to `t.plan()` out how many assertions you are going to run and you\ndon't call `t.end()` explicitly, your test will hang.\n\n## test.skip([name], [opts], cb)\n\nGenerate a new test that will be skipped over.\n\n## test.teardown(cb)\n\nRegister a callback to run after the individual test has completed. Multiple registered teardown callbacks will run in order. Useful for undoing side effects, closing network connections, etc.\n\n## test.onFinish(fn)\n\nThe onFinish hook will get invoked when ALL `tape` tests have finished\nright before `tape` is about to print the test summary.\n\n## test.onFailure(fn)\n\nThe onFailure hook will get invoked whenever any `tape` tests has failed.\n\n## t.plan(n)\n\nDeclare that `n` assertions should be run. `t.end()` will be called\nautomatically after the `n`th assertion. If there are any more assertions after\nthe `n`th, or after `t.end()` is called, they will generate errors.\n\n## t.end(err)\n\nDeclare the end of a test explicitly. If `err` is passed in `t.end` will assert\nthat it is falsey.\n\n## t.fail(msg)\n\nGenerate a failing assertion with a message `msg`.\n\n## t.pass(msg)\n\nGenerate a passing assertion with a message `msg`.\n\n## t.timeoutAfter(ms)\n\nAutomatically timeout the test after X ms.\n\n## t.skip(msg)\n\nGenerate an assertion that will be skipped over.\n\n## t.ok(value, msg)\n\nAssert that `value` is truthy with an optional description of the assertion `msg`.\n\nAliases: `t.true()`, `t.assert()`\n\n## t.notOk(value, msg)\n\nAssert that `value` is falsy with an optional description of the assertion `msg`.\n\nAliases: `t.false()`, `t.notok()`\n\n## t.error(err, msg)\n\nAssert that `err` is falsy. If `err` is non-falsy, use its `err.message` as the\ndescription message.\n\nAliases: `t.ifError()`, `t.ifErr()`, `t.iferror()`\n\n## t.equal(actual, expected, msg)\n\nAssert that `actual === expected` with an optional description of the assertion `msg`.\n\nAliases: `t.equals()`, `t.isEqual()`, `t.is()`, `t.strictEqual()`,\n`t.strictEquals()`\n\n## t.notEqual(actual, expected, msg)\n\nAssert that `actual !== expected` with an optional description of the assertion `msg`.\n\nAliases: `t.notEquals()`, `t.notStrictEqual()`, `t.notStrictEquals()`,\n`t.isNotEqual()`, `t.isNot()`, `t.not()`, `t.doesNotEqual()`, `t.isInequal()`\n\n## t.deepEqual(actual, expected, msg)\n\nAssert that `actual` and `expected` have the same structure and nested values using\n[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)\nwith strict comparisons (`===`) on leaf nodes and an optional description of the assertion `msg`.\n\nAliases: `t.deepEquals()`, `t.isEquivalent()`, `t.same()`\n\n## t.notDeepEqual(actual, expected, msg)\n\nAssert that `actual` and `expected` do not have the same structure and nested values using\n[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)\nwith strict comparisons (`===`) on leaf nodes and an optional description of the assertion `msg`.\n\nAliases: `t.notDeepEquals`, `t.notEquivalent()`, `t.notDeeply()`, `t.notSame()`,\n`t.isNotDeepEqual()`, `t.isNotDeeply()`, `t.isNotEquivalent()`,\n`t.isInequivalent()`\n\n## t.deepLooseEqual(actual, expected, msg)\n\nAssert that `actual` and `expected` have the same structure and nested values using\n[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)\nwith loose comparisons (`==`) on leaf nodes and an optional description of the assertion `msg`.\n\nAliases: `t.looseEqual()`, `t.looseEquals()`\n\n## t.notDeepLooseEqual(actual, expected, msg)\n\nAssert that `actual` and `expected` do not have the same structure and nested values using\n[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)\nwith loose comparisons (`==`) on leaf nodes and an optional description of the assertion `msg`.\n\nAliases: `t.notLooseEqual()`, `t.notLooseEquals()`\n\n## t.throws(fn, expected, msg)\n\nAssert that the function call `fn()` throws an exception. `expected`, if present, must be a `RegExp`, `Function`, or `Object`. The `RegExp` matches the string representation of the exception, as generated by `err.toString()`. For example, if you set `expected` to `/user/`, the test will pass only if the string representation of the exception contains the word `user`. Any other exception will result in a failed test. The `Function` is the exception thrown (e.g. `Error`). `Object` in this case corresponds to a so-called validation object, in which each property is tested for strict deep equality. As an example, see the following two tests--each passes a validation object to `t.throws()` as the second parameter. The first test will pass, because all property values in the actual error object are deeply strictly equal to the property values in the validation object.\n```\n    const err = new TypeError(\"Wrong value\");\n    err.code = 404;\n    err.check = true;\n\n    // Passing test.\n    t.throws(\n        () => {\n            throw err;\n        },\n        {\n            code: 404,\n            check: true\n        },\n        \"Test message.\"\n    );\n```\nThis next test will fail, because all property values in the actual error object are _not_ deeply strictly equal to the property values in the validation object.\n```\n    const err = new TypeError(\"Wrong value\");\n    err.code = 404;\n    err.check = \"true\";\n\n    // Failing test.\n    t.throws(\n        () => {\n            throw err;\n        },\n        {\n            code: 404,\n            check: true // This is not deeply strictly equal to err.check.\n        },\n        \"Test message.\"\n    );\n```\n\nThis is very similar to how Node's `assert.throws()` method tests validation objects (please see the [Node _assert.throws()_ documentation](https://nodejs.org/api/assert.html#assert_assert_throws_fn_error_message) for more information).\n\nIf `expected` is not of type `RegExp`, `Function`, or `Object`, or omitted entirely, any exception will result in a passed test. `msg` is an optional description of the assertion.\n\nPlease note that the second parameter, `expected`, cannot be of type `string`. If a value of type `string` is provided for `expected`, then `t.throws(fn, expected, msg)`  will execute, but the value of `expected` will be set to  `undefined`, and the specified string will be set as the value for the `msg` parameter (regardless of what _actually_ passed as the third parameter). This can cause unexpected results, so please be mindful.\n\n## t.doesNotThrow(fn, expected, msg)\n\nAssert that the function call `fn()` does not throw an exception. `expected`, if present, limits what should not be thrown. For example, set `expected` to `/user/` to fail the test only if the string representation of the exception contains the word `user`. Any other exception would pass the test. If `expected` is omitted, any exception will fail the test. `msg` is an optional description of the assertion.\n\n## t.test(name, [opts], cb)\n\nCreate a subtest with a new test handle `st` from `cb(st)` inside the current\ntest `t`. `cb(st)` will only fire when `t` finishes. Additional tests queued up\nafter `t` will not be run until all subtests finish.\n\nYou may pass the same options that [`test()`](#testname-opts-cb) accepts.\n\n## t.comment(message)\n\nPrint a message without breaking the tap output. (Useful when using e.g. `tap-colorize` where output is buffered & `console.log` will print in incorrect order vis-a-vis tap output.)\n\n## t.match(string, regexp, message)\n\nAssert that `string` matches the RegExp `regexp`. Will throw (not just fail) when the first two arguments are the wrong type.\n\n## t.doesNotMatch(string, regexp, message)\n\nAssert that `string` does not match the RegExp `regexp`. Will throw (not just fail) when the first two arguments are the wrong type.\n\n## var htest = test.createHarness()\n\nCreate a new test harness instance, which is a function like `test()`, but with\na new pending stack and test state.\n\nBy default the TAP output goes to `console.log()`. You can pipe the output to\nsomeplace else if you `htest.createStream().pipe()` to a destination stream on\nthe first tick.\n\n## test.only([name], [opts], cb)\n\nLike `test([name], [opts], cb)` except if you use `.only` this is the only test case\nthat will run for the entire process, all other test cases using `tape` will\nbe ignored.\n\n## var stream = test.createStream(opts)\n\nCreate a stream of output, bypassing the default output stream that writes\nmessages to `console.log()`. By default `stream` will be a text stream of TAP\noutput, but you can get an object stream instead by setting `opts.objectMode` to\n`true`.\n\n### tap stream reporter\n\nYou can create your own custom test reporter using this `createStream()` api:\n\n``` js\nvar test = require('tape');\nvar path = require('path');\n\ntest.createStream().pipe(process.stdout);\n\nprocess.argv.slice(2).forEach(function (file) {\n    require(path.resolve(file));\n});\n```\n\nYou could substitute `process.stdout` for whatever other output stream you want,\nlike a network connection or a file.\n\nPass in test files to run as arguments:\n\n```sh\n$ node tap.js test/x.js test/y.js\nTAP version 13\n# (anonymous)\nnot ok 1 should be equal\n  ---\n    operator: equal\n    expected: \"boop\"\n    actual:   \"beep\"\n  ...\n# (anonymous)\nok 2 should be equal\nok 3 (unnamed assert)\n# wheee\nok 4 (unnamed assert)\n\n1..4\n# tests 4\n# pass  3\n# fail  1\n```\n\n### object stream reporter\n\nHere's how you can render an object stream instead of TAP:\n\n``` js\nvar test = require('tape');\nvar path = require('path');\n\ntest.createStream({ objectMode: true }).on('data', function (row) {\n    console.log(JSON.stringify(row))\n});\n\nprocess.argv.slice(2).forEach(function (file) {\n    require(path.resolve(file));\n});\n```\n\nThe output for this runner is:\n\n```sh\n$ node object.js test/x.js test/y.js\n{\"type\":\"test\",\"name\":\"(anonymous)\",\"id\":0}\n{\"id\":0,\"ok\":false,\"name\":\"should be equal\",\"operator\":\"equal\",\"actual\":\"beep\",\"expected\":\"boop\",\"error\":{},\"test\":0,\"type\":\"assert\"}\n{\"type\":\"end\",\"test\":0}\n{\"type\":\"test\",\"name\":\"(anonymous)\",\"id\":1}\n{\"id\":0,\"ok\":true,\"name\":\"should be equal\",\"operator\":\"equal\",\"actual\":2,\"expected\":2,\"test\":1,\"type\":\"assert\"}\n{\"id\":1,\"ok\":true,\"name\":\"(unnamed assert)\",\"operator\":\"ok\",\"actual\":true,\"expected\":true,\"test\":1,\"type\":\"assert\"}\n{\"type\":\"end\",\"test\":1}\n{\"type\":\"test\",\"name\":\"wheee\",\"id\":2}\n{\"id\":0,\"ok\":true,\"name\":\"(unnamed assert)\",\"operator\":\"ok\",\"actual\":true,\"expected\":true,\"test\":2,\"type\":\"assert\"}\n{\"type\":\"end\",\"test\":2}\n```\n\nA convenient alternative to achieve the same:\n```js\n// report.js\nvar test = require('tape');\n\ntest.createStream({ objectMode: true }).on('data', function (row) {\n    console.log(JSON.stringify(row)) // for example\n});\n```\nand then:\n```sh\n$ tape -r ./report.js **/*.test.js\n```\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```sh\nnpm install tape --save-dev\n```\n\n# license\n\nMIT\n\n[codecov-image]: https://codecov.io/gh/substack/tape/branch/master/graphs/badge.svg\n[codecov-url]: https://app.codecov.io/gh/substack/tape/\n[actions-image]: https://img.shields.io/endpoint?url=https://github-actions-badge-u3jn4tfpocch.runkit.sh/substack/tape\n[actions-url]: https://github.com/substack/tape/actions\n",
  "readmeFilename": "readme.markdown",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/tape.git"
  },
  "scripts": {
    "lint": "eslint . bin/*",
    "posttest": "aud --production",
    "prelint": "eclint check",
    "prepublish": "!(type not-in-publish) || not-in-publish || npm run prepublishOnly",
    "prepublishOnly": "safe-publish-latest",
    "pretest": "npm run lint",
    "test": "npm run tests-only",
    "tests-only": "nyc tap test/*.js"
  },
  "testling": {
    "browsers": [
      "chrome/20..latest",
      "firefox/10..latest",
      "ie/6..latest",
      "ipad/6",
      "iphone/6",
      "opera/11.0..latest",
      "safari/latest"
    ],
    "files": "test/browser/*.js"
  },
  "version": "4.14.0"
}
